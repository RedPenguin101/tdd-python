# Chapter 2: Extending our functional test using unittest module
https://learning.oreilly.com/library/view/test-driven-development-with/9781491958698/ch02.html

1. we are (cliche) building a todo list.

## Using a functional test to scope out a minimum viable app.

1. selenium drives a real web browser, so they let us see how the app functions from the users POV - so it's a functional test.
2. FTs tend to track user stories.
3. AKA acceptance test, end-to-end test, black box test
4. Human readable narrative.
5. MVP for todolist: enter todos and remember them
6. amend your FT to include a story like structure in comments. also chanage the header you are testing for
7. note that comments are lies. it's pointless to write a comment that just repeats what you code is doing:

```py
# increment by 1
i += 1
```

8. your code should be readable enough that this isn't necessary
9. you'll get an assertion error when you run the test - an _expected fail_.

## unittest
1. unittest lets you put structure around your tests.
2. change your test to use classes and functions, with a execution main.

```py
from selenium import webdriver
import unittest


class NewVisitorTest(unittest.TestCase):
    def setUp(self):
        self.browser = webdriver.Firefox()

    def tearDown(self):
        self.browser.quit()

    def test_can_start_a_list_and_retrieve_it_later(self):
        # edith has learned about your new todo app. she goes to the page
        self.browser.get('http://localhost:8000')

        # she notices the page title and header mention to-do lists
        self.assertIn('To-Do', self.browser.title)
        self.fail('Finish the test')

        # she is invited to enter a to-do item straight away
        # other comments

if __name__ == '__main__':
    unittest.main(warnings='ignore')
```

3. Tests are grouped into classes, which inherit from `unittest.TestCase`
4. any method which starts with `test` is a test method. give them descriptive names
5. `setUp` and `tearDown` are special methods that get run before and after each test.
6. `assertIn` is a helper function, gives us a bit more power in our assertions
7. `self.fail` is just an automatic fail
8. `warnings='ignore'` supressions some superflous stuff. try without it first
9. do a commit here

